/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// main.ts
__export(exports, {
  AliasSuggestModal: () => AliasSuggestModal,
  TagSuggestModal: () => TagSuggestModal,
  default: () => AutoMOC
});
var import_obsidian = __toModule(require("obsidian"));
var importListTypes;
(function(importListTypes2) {
  importListTypes2["Disabled"] = "DISABLE";
  importListTypes2["OrderedList"] = "ORDERED";
  importListTypes2["UnorderedList"] = "UNORDERED";
  importListTypes2["CheckBox"] = "CHECKBOX";
})(importListTypes || (importListTypes = {}));
var orderedListDelimeters;
(function(orderedListDelimeters2) {
  orderedListDelimeters2["Parenthesis"] = ")";
  orderedListDelimeters2["Period"] = ".";
})(orderedListDelimeters || (orderedListDelimeters = {}));
var itemTypes;
(function(itemTypes2) {
  itemTypes2["Link"] = "LINK";
  itemTypes2["Tag"] = "TAG";
  itemTypes2["Alias"] = "ALIAS";
})(itemTypes || (itemTypes = {}));
var DEFAULT_SETTINGS = {
  showRibbonButton: true,
  linkToHeading: false,
  onlyLinkToPrecedingHeading: false,
  linkWithAlias: true,
  importAsList: importListTypes.Disabled,
  orderedListSeparator: orderedListDelimeters.Period,
  ignoredFolders: "",
  linkingMentionsNotice: true,
  noNewLinksNotice: true,
  newLinksAddedNotice: false
};
var TagSuggestModal = class extends import_obsidian.FuzzySuggestModal {
  constructor(app2, plugin) {
    super(app2);
    this.plugin = plugin;
  }
  onOpen() {
    this.setPlaceholder("Import notes with tags matching...");
    this.setInstructions([
      { command: "\u2191\u2193", purpose: "to navigate" },
      { command: "\u21B5", purpose: "to select tag" },
      { command: "esc", purpose: "to dismiss" }
    ]);
    this.inputEl.focus();
  }
  onClose() {
    let { contentEl } = this;
    contentEl.empty();
  }
  getItems() {
    const allFiles = this.app.metadataCache.resolvedLinks;
    let tagsSet = new Set();
    Object.keys(allFiles).forEach((key) => {
      const file = this.app.vault.getAbstractFileByPath(key);
      if (file instanceof import_obsidian.TFile) {
        const body_tags = app.metadataCache.getFileCache(file).tags;
        const frontmatter = this.app.metadataCache.getFileCache(file).frontmatter;
        if (body_tags) {
          for (const tag of body_tags) {
            tagsSet.add(tag["tag"]);
          }
        }
        let f_tags = [];
        if (frontmatter) {
          if (Array.isArray(frontmatter["tags"])) {
            f_tags = frontmatter["tags"];
            for (const f_tag of f_tags) {
              tagsSet.add("#" + f_tag);
            }
          }
          if (String.isString(frontmatter["tags"])) {
            f_tags = frontmatter["tags"].split(", ");
            for (const f_tag of f_tags) {
              tagsSet.add("#" + f_tag);
            }
          }
        }
      }
    });
    return Array.from(tagsSet).sort();
  }
  getItemText(item) {
    return item;
  }
  onChooseItem(item, evt) {
    this.selection = item;
    this.plugin.runAutoMOC(itemTypes.Tag, item);
  }
};
var AliasSuggestModal = class extends import_obsidian.FuzzySuggestModal {
  constructor(app2, plugin) {
    super(app2);
    this.plugin = plugin;
  }
  onOpen() {
    this.setPlaceholder("Import notes with alias matching...");
    this.setInstructions([
      { command: "\u2191\u2193", purpose: "to navigate" },
      { command: "\u21B5", purpose: "to select tag" },
      { command: "esc", purpose: "to dismiss" }
    ]);
    this.inputEl.focus();
  }
  onClose() {
    let { contentEl } = this;
    contentEl.empty();
  }
  getItems() {
    const allFiles = this.app.metadataCache.resolvedLinks;
    let aliasSet = new Set();
    Object.keys(allFiles).forEach((key) => {
      const file = this.app.vault.getAbstractFileByPath(key);
      if (file instanceof import_obsidian.TFile) {
        const frontmatter = this.app.metadataCache.getFileCache(file).frontmatter;
        let aliases = [];
        if (frontmatter) {
          if (Array.isArray(frontmatter["aliases"])) {
            aliases = frontmatter["aliases"];
            for (const alias of aliases) {
              aliasSet.add(alias);
            }
          }
          if (String.isString(frontmatter["aliases"])) {
            aliases = frontmatter["aliases"].split(", ");
            for (const alias of aliases) {
              aliasSet.add(alias);
            }
          }
        }
      }
    });
    return Array.from(aliasSet).sort();
  }
  getItemText(item) {
    return item;
  }
  onChooseItem(item, evt) {
    this.selection = item;
    this.plugin.runAutoMOC(itemTypes.Alias, item);
  }
};
var AutoMOC = class extends import_obsidian.Plugin {
  getPresentLinks(currFilePath) {
    const allFiles = this.app.metadataCache.resolvedLinks;
    const presentLinks = Object.keys(allFiles[currFilePath]);
    return presentLinks.sort();
  }
  getHeadings(path, activeFileView, item, linkLocations) {
    return __async(this, null, function* () {
      let closestHeading = "";
      let allHeadings = [];
      if (this.settings.linkToHeading) {
        const headingsLocations = yield this.getHeadingsLocationsInFile(path);
        let linkTagLocations = [];
        if (linkLocations) {
          linkTagLocations = linkLocations;
        } else {
          linkTagLocations = yield this.getItemLocationsInFile(activeFileView, path, item);
        }
        for (let i = 0; i < linkTagLocations.length; i++) {
          closestHeading = this.determineClosestHeading(headingsLocations, linkTagLocations[i]);
          if (closestHeading)
            allHeadings.push(closestHeading);
        }
      }
      return allHeadings;
    });
  }
  getLinkedMentions(currFilePath, activeFileView, item) {
    return __async(this, null, function* () {
      let linkedMentions = [];
      let ignoredFolders = this.settings.ignoredFolders.trim().split(",").map((str) => str.trim().replace(/^\/|\/$/g, "")).filter((n) => n);
      let workAroundSuccess = false;
      if (typeof this.app.metadataCache.getBacklinksForFile === "function") {
        const file = this.app.vault.getAbstractFileByPath(currFilePath);
        const backLinks = this.app.metadataCache.getBacklinksForFile(file);
        if (backLinks && backLinks.data) {
          workAroundSuccess = true;
          for (const linkFile of backLinks.data) {
            if (linkFile.length >= 2) {
              const linkPath = linkFile[0];
              if (!ignoredFolders.some((path) => linkPath.includes(path))) {
                let linkLocations = [];
                for (const iter of linkFile[1]) {
                  if (iter.position && iter.position.start) {
                    linkLocations.push(iter.position.start.line);
                  }
                }
                const allHeadings = yield this.getHeadings(linkPath, activeFileView, item, linkLocations);
                linkedMentions.push({
                  path: linkPath,
                  headings: allHeadings
                });
              }
            }
          }
        }
      }
      if (!workAroundSuccess) {
        const allFiles = this.app.metadataCache.resolvedLinks;
        for (const key of Object.keys(allFiles)) {
          if (!ignoredFolders.some((path) => key.includes(path))) {
            if (currFilePath in allFiles[key]) {
              const allHeadings = yield this.getHeadings(key, activeFileView, item);
              linkedMentions.push({
                path: key,
                headings: allHeadings
              });
            }
          }
        }
      }
      return linkedMentions.sort((a, b) => a.path.localeCompare(b.path, void 0, { sensitivity: "base" }));
    });
  }
  getTaggedMentions(activeFileView, tag) {
    return __async(this, null, function* () {
      const allFiles = this.app.metadataCache.resolvedLinks;
      let taggedMentions = [];
      const toCompare = tag.replace("#", "");
      let ignoredFolders = this.settings.ignoredFolders.trim().split(",").map((str) => str.trim().replace(/^\/|\/$/g, "")).filter((n) => n);
      for (const key of Object.keys(allFiles)) {
        if (!ignoredFolders.some((path) => key.includes(path))) {
          const file = this.app.vault.getAbstractFileByPath(key);
          if (file instanceof import_obsidian.TFile) {
            const body_tags = app.metadataCache.getFileCache(file).tags;
            const frontmatter = this.app.metadataCache.getFileCache(file).frontmatter;
            if (body_tags) {
              for (const tag2 of body_tags) {
                if (tag2["tag"].replace("#", "") === toCompare) {
                  taggedMentions.push({
                    path: file.path,
                    headings: []
                  });
                }
              }
            }
            if (frontmatter) {
              let f_tags = [];
              if (Array.isArray(frontmatter["tags"])) {
                f_tags = frontmatter["tags"];
                for (const f_tag of f_tags) {
                  if (f_tag === toCompare) {
                    taggedMentions.push({
                      path: file.path,
                      headings: []
                    });
                  }
                }
              }
              if (String.isString(frontmatter["tags"])) {
                f_tags = frontmatter["tags"].split(", ");
                for (const f_tag of f_tags) {
                  if (f_tag === toCompare) {
                    taggedMentions.push({
                      path: file.path,
                      headings: []
                    });
                  }
                }
              }
            }
          }
        }
      }
      const uniqueTaggedMentions = taggedMentions.filter((value, index, array) => {
        const pos = array.findIndex((element) => element.path == value.path);
        return pos === index;
      });
      for (let mention of uniqueTaggedMentions) {
        mention.headings = yield this.getHeadings(mention.path, activeFileView, tag);
      }
      return uniqueTaggedMentions;
    });
  }
  getAliasMentions(activeFileView, refAlias) {
    return __async(this, null, function* () {
      const allFiles = this.app.metadataCache.resolvedLinks;
      let aliasMentions = [];
      let ignoredFolders = this.settings.ignoredFolders.trim().split(",").map((str) => str.trim().replace(/^\/|\/$/g, "")).filter((n) => n);
      for (const key of Object.keys(allFiles)) {
        if (!ignoredFolders.some((path) => key.includes(path))) {
          const file = this.app.vault.getAbstractFileByPath(key);
          if (file instanceof import_obsidian.TFile) {
            const frontmatter = this.app.metadataCache.getFileCache(file).frontmatter;
            if (frontmatter) {
              let aliases = [];
              if (Array.isArray(frontmatter["aliases"])) {
                aliases = frontmatter["aliases"];
                for (const alias of aliases) {
                  if (alias === refAlias) {
                    aliasMentions.push({
                      path: file.path,
                      headings: []
                    });
                  }
                }
              }
              if (String.isString(frontmatter["aliases"])) {
                aliases = frontmatter["aliases"].split(", ");
                for (const alias of aliases) {
                  if (alias === refAlias) {
                    aliasMentions.push({
                      path: file.path,
                      headings: []
                    });
                  }
                }
              }
            }
          }
        }
      }
      const uniqueAliasMentions = aliasMentions.filter((value, index, array) => {
        const pos = array.findIndex((element) => element.path == value.path);
        return pos === index;
      });
      for (let mention of uniqueAliasMentions) {
        mention.headings = yield this.getHeadings(mention.path, activeFileView, refAlias);
      }
      return uniqueAliasMentions;
    });
  }
  addMissingLinks(activeFileView, presentLinks, allLinkedMentions) {
    return __async(this, null, function* () {
      let addFlag = false;
      let listChar = "";
      let listIter = -1;
      let importPrefix = "";
      if (this.settings.importAsList === importListTypes.UnorderedList) {
        listChar = "*";
        importPrefix = listChar + " ";
      } else if (this.settings.importAsList === importListTypes.CheckBox) {
        listChar = "- [ ]";
        importPrefix = listChar + " ";
      } else if (this.settings.importAsList == importListTypes.OrderedList) {
        listChar = this.settings.orderedListSeparator;
        listIter = 1;
        importPrefix = listIter + listChar + " ";
      }
      for (const mention of allLinkedMentions) {
        const path = mention.path;
        if (!presentLinks.includes(path)) {
          const file = this.app.vault.getAbstractFileByPath(path);
          if (file instanceof import_obsidian.TFile) {
            const frontmatter = this.app.metadataCache.getFileCache(file).frontmatter;
            let alias = "";
            if (this.settings.linkWithAlias && frontmatter && Array.isArray(frontmatter["aliases"]) && frontmatter["aliases"].length > 0) {
              alias = frontmatter.aliases[0];
            }
            const allHeadings = mention.headings;
            if (allHeadings.length > 0) {
              for (let i = 0; i < allHeadings.length; i++) {
                activeFileView.editor.replaceSelection(importPrefix + this.app.fileManager.generateMarkdownLink(file, activeFileView.file.path, "#" + allHeadings[i], alias) + "\n");
              }
            } else {
              activeFileView.editor.replaceSelection(importPrefix + this.app.fileManager.generateMarkdownLink(file, activeFileView.file.path, void 0, alias) + "\n");
            }
            if (this.settings.importAsList === importListTypes.OrderedList) {
              listIter += 1;
              importPrefix = listIter + listChar + " ";
            }
            addFlag = true;
          }
        }
      }
      if (this.settings.newLinksAddedNotice && addFlag)
        new import_obsidian.Notice("New links added to note");
      else if (this.settings.noNewLinksNotice && !addFlag)
        new import_obsidian.Notice("No new links found");
    });
  }
  getHeadingsLocationsInFile(filePath) {
    return __async(this, null, function* () {
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (file instanceof import_obsidian.TFile) {
        const fileContent = yield this.app.vault.read(file);
        const lines = fileContent.split("\n");
        const regXHeader = /#{1,6}\s.+(?=)/g;
        let headings = [];
        lines.forEach((line) => {
          const match = line.match(regXHeader);
          if (match)
            headings.push(match[0].replace(/#{1,6}\s/g, ""));
          else
            headings.push("-1");
        });
        return headings;
      }
    });
  }
  getItemLocationsInFile(activeFileView, filePath, item) {
    return __async(this, null, function* () {
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (file instanceof import_obsidian.TFile) {
        const fileContent = yield this.app.vault.read(file);
        const lines = fileContent.split("\n");
        let lineContent = [];
        const activeFileName = activeFileView.file.name.substring(0, activeFileView.file.name.length - 3);
        let toSearch = "";
        if (!item) {
          toSearch = "[[" + activeFileName + "]]";
        } else
          toSearch = item;
        lines.forEach((line) => {
          if (line.includes(toSearch))
            lineContent.push(toSearch);
          else
            lineContent.push("-1");
        });
        let toReturn = [];
        for (let i = 0; i < lineContent.length; i++) {
          if (lineContent[i] === toSearch)
            toReturn.push(i);
        }
        return toReturn;
      }
    });
  }
  determineClosestHeading(headingsLocations, itemLocation) {
    let distances = [];
    headingsLocations.forEach((item, index) => {
      let distance = Infinity;
      if (item != "-1") {
        if (this.settings.onlyLinkToPrecedingHeading) {
          if (index <= itemLocation) {
            distance = itemLocation - index;
          }
        } else {
          distance = Math.abs(index - itemLocation);
        }
      }
      distances.push(distance);
    });
    let minIndex = -1;
    let minValue = Infinity;
    for (let i = 0; i < distances.length; i += 1) {
      if (distances[i] < minValue) {
        minIndex = i;
        minValue = distances[i];
      }
    }
    if (minIndex === itemLocation) {
      headingsLocations[minIndex] = headingsLocations[minIndex].replace(/#/g, "").trim();
    }
    return headingsLocations[minIndex];
  }
  runAutoMOC(itemType, item) {
    return __async(this, null, function* () {
      if (!Object.values(itemTypes).includes(itemType)) {
        new import_obsidian.Notice("Invalid itemType provided");
        return;
      }
      const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
      if (view != null && view.file.extension === "md") {
        if (this.settings.linkingMentionsNotice)
          new import_obsidian.Notice("Linking mentions");
        const presentLinks = this.getPresentLinks(view.file.path);
        let linkTagMentions;
        if (itemType == itemTypes.Link) {
          linkTagMentions = yield this.getLinkedMentions(view.file.path, view, item);
        } else if (itemType == itemTypes.Tag) {
          linkTagMentions = yield this.getTaggedMentions(view, item);
        } else if (itemType == itemTypes.Alias) {
          linkTagMentions = yield this.getAliasMentions(view, item);
        }
        this.addMissingLinks(view, presentLinks, linkTagMentions);
      } else {
        new import_obsidian.Notice("Failed to link mentions, file type is not a markdown file");
      }
    });
  }
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      if (this.settings.showRibbonButton) {
        const ribbonIconEl = this.addRibbonIcon("sheets-in-box", "AutoMOC", (evt) => {
          this.runAutoMOC(itemTypes.Link);
        });
      }
      this.addCommand({
        id: "add-missing-linked-mentions",
        name: "Add missing linked mentions at the cursor position",
        editorCallback: (editor, view) => {
          this.runAutoMOC(itemTypes.Link);
        }
      });
      this.addCommand({
        id: "add-missing-notes-by-tag",
        name: "Add missing notes with a specific tag at the current cursor location",
        editorCallback: (editor, view) => {
          new TagSuggestModal(this.app, this).open();
        }
      });
      this.addCommand({
        id: "add-missing-notes-by-alias",
        name: "Add missing notes with a specific alias at the current cursor location",
        editorCallback: (editor, view) => {
          new AliasSuggestModal(this.app, this).open();
        }
      });
      this.addSettingTab(new AutoMOCSettingTab(this.app, this));
    });
  }
  onunload() {
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
};
var AutoMOCSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Functionality" });
    new import_obsidian.Setting(containerEl).setName("Show ribbon button").setDesc("Enable or disable the ribbon button for this plugin. You can still run the plugin with a hotkey (requires restart)").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.showRibbonButton).onChange((showRibbonButton) => {
        this.plugin.settings.showRibbonButton = showRibbonButton;
        this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Link to heading").setDesc("Creates the link to the heading closest to the link/tag. This is performed in a greedy manner").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.linkToHeading).onChange((linkToHeading) => {
        this.plugin.settings.linkToHeading = linkToHeading;
        this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Only link to preceding heading").setDesc("When 'Link to heading' is enabled, a heading will only be added to a link if the heading precedes the link/tag").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.onlyLinkToPrecedingHeading).onChange((onlyLinkToPrecedingHeading) => {
        this.plugin.settings.onlyLinkToPrecedingHeading = onlyLinkToPrecedingHeading;
        this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Create link with alias").setDesc("Creates the link with the first alias from the frontmatter").addToggle((toggle) => toggle.setValue(this.plugin.settings.linkWithAlias).onChange((linkWithAlias) => {
      this.plugin.settings.linkWithAlias = linkWithAlias;
      this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Import as list").setDesc("Choose whether to import the links directly or as a ordered/unordered list").addDropdown((dropdown) => {
      dropdown.addOption(importListTypes.Disabled, "Disabled").addOption(importListTypes.OrderedList, "Ordered List").addOption(importListTypes.UnorderedList, "Unordered List").addOption(importListTypes.CheckBox, "Checkbox").setValue(this.plugin.settings.importAsList).onChange((importValue) => {
        this.plugin.settings.importAsList = importValue;
        this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Ordered list separator character").setDesc('If "Import as List" is set to "Ordered List" - Set what character separates the number from the list item').addDropdown((dropdown) => {
      dropdown.addOption(orderedListDelimeters.Period, "Period").addOption(orderedListDelimeters.Parenthesis, "Parenthesis").setValue(this.plugin.settings.orderedListSeparator).onChange((value) => {
        this.plugin.settings.orderedListSeparator = value;
        this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Ignore notes in folders").setDesc("Specify a comma separated list of folders whose note's backlinks will not be added when AutoMOC is run 				(start from the root of your vault)").addText((text) => text.setPlaceholder("path1, path2, path 3...").setValue(this.plugin.settings.ignoredFolders).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.ignoredFolders = value;
      yield this.plugin.saveSettings();
    })));
    containerEl.createEl("h2", { text: "Notifications" });
    new import_obsidian.Setting(containerEl).setName("Linking mentions").setDesc("Enable or disable notifications for when AutoMoc begins to run").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.linkingMentionsNotice).onChange((value) => {
        this.plugin.settings.linkingMentionsNotice = value;
        this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("New links added").setDesc("Enable or disable notifications for when new links are added to a note").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.newLinksAddedNotice).onChange((value) => {
        this.plugin.settings.newLinksAddedNotice = value;
        this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("No new links found").setDesc("Enable or disable notifications for when no new links are added to a note").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.noNewLinksNotice).onChange((value) => {
        this.plugin.settings.noNewLinksNotice = value;
        this.plugin.saveSettings();
      });
    });
  }
};


/* nosourcemap */